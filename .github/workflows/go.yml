# This workflow will build a golang project
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-go

name: Go build & test
permissions:
  contents: read

on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["**"]
  workflow_dispatch: {}

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      MODULE_DIRS: "handler io"

    steps:
      - uses: actions/checkout@v4

      - name: Read minimum Go version from go.mod
        id: goversion
        run: echo "GO_VERSION=$(grep '^go ' go.mod | cut -d' ' -f2)" >> $GITHUB_ENV

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Discover modules (root + MODULE_DIRS)
        id: discover-modules
        run: |
          # Always include root
          printf ".\n" > modules.txt

          # MODULE_DIRS is a space-separated list
          for d in $MODULE_DIRS; do
            if [ -d "$d" ]; then
              find "$d" -type f -name go.mod -print | sed 's|/go.mod$||' >> modules.txt || true
            fi
          done

          # dedupe and normalize
          sort -u modules.txt -o modules.txt

          echo "modules<<EOF" >> $GITHUB_OUTPUT
          cat modules.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Build & test every discovered module
        run: |
          set -euo pipefail
          mkdir -p coverage
          REPO_ROOT="$(pwd)"
          MODS="${{ steps.discover-modules.outputs.modules }}"
          echo "Modules to process:"
          echo "$MODS"

          while IFS= read -r dir; do
            [ -z "$dir" ] && continue
            echo "=== Module: $dir ==="

            # Change to module directory but track repo root
            cd "$REPO_ROOT/$dir"

            echo "> go build ./..."
            go build -v ./... || { echo "ERROR: Build failed in $dir"; exit 1; }

            safe=$(echo "$dir" | sed 's#[/\.]#-#g' | sed 's/^-//; s/-$//')
            [ -z "$safe" ] && safe=root

            echo "> go test (cover) -> coverage/${safe}.out"
            # Use absolute path to coverage file
            go test -v -covermode=count -coverprofile="$REPO_ROOT/coverage/${safe}.out" ./...

            # Tag coverage file with flag for Codecov
            if [ -f "$REPO_ROOT/coverage/${safe}.out" ]; then
              # Prepend flag comment to coverage file
              echo "# flags: $safe" | cat - "$REPO_ROOT/coverage/${safe}.out" > "$REPO_ROOT/coverage/${safe}.out.tmp"
              mv "$REPO_ROOT/coverage/${safe}.out.tmp" "$REPO_ROOT/coverage/${safe}.out"
            fi

            # Return to repo root for next iteration
            cd "$REPO_ROOT"
          done <<< "$MODS"

          # merge coverage files if any
          if compgen -G "coverage/*.out" >/dev/null; then
            echo "Merging coverage files..."
            go install github.com/wadey/gocovmerge@latest
            "${GOPATH:-$HOME/go}/bin/gocovmerge" coverage/*.out > coverage.txt
          fi

      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: coverage.txt
